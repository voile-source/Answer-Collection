/**
题目描述
棋盘上 AA 点有一个过河卒，需要走到目标 BB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CC 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，AA 点 (0, 0)(0,0)、BB 点 (n, m)(n,m)，同样马的位置坐标是需要给出的。



现在要求你计算出卒从 AA 点能够到达 BB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

输入格式
一行四个正整数，分别表示 BB 点坐标和马的坐标。

输出格式
一个整数，表示所有的路径条数。

输入输出样例
输入 #1复制
6 6 3 3
输出 #1复制
6
说明/提示
对于 100 \%100% 的数据，1 \le n, m \le 201≤n,m≤20，0 \le0≤ 马的坐标 \le 20≤20。

解题思路：dp[i][j]存储经过该点的路径的条数，我们先标记好马和马脚的位置，然后判断当前路径是否经过马脚，若经过，则经过该点的路径条数为0；
**/

#include<iostream>
using namespace std;

long long dp[25][25],s[25][25];
int nx[8]={1,2,2,1,-1,-2,-2,-1};
int ny[8]={2,1,-1,-2,-2,-1,1,2};
int ax,ay,n,m;

int main()
{
	cin>>ax>>ay>>n>>m;
	s[n][m]=1;
	for(int i=0;i<8;i++){
		int l=n+nx[i],r=m+ny[i];
		if(l>=0&&r>=0&&l<=ax&&r<=ay)s[l][r]=1;
	}
	dp[0][0]=1;
	for(int i=0;i<=ax;i++){
		for(int j=0;j<=ay;j++){
			if(!i&&!j||s[i][j])continue;
			else{
				if(i)dp[i][j]+=dp[i-1][j];
				if(j)dp[i][j]+=dp[i][j-1];
			}
		} 
	} 
	cout<<dp[ax][ay];
}
