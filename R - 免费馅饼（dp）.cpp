/**
最近阿彭的股票一片绿，本着大跌就是加仓信号的原则，阿彭急需一大笔资金投入股票市场。

上帝可能可怜阿彭的不切实际想法，给了他一场白日梦，即白日做梦之捡钞票游戏。

捡钞票游戏是这样的，钞票从天上往下掉，且只会掉在 [0, 10] 范围内，具体的坐标范围如下图所示。


阿彭初始站在位置5上，且每秒只能在移动不超过1米的范围内接住掉落的钞票，如果没有接住，钞票就会消失。例如，在刚开始的一秒内，阿彭 只能接到4、5、6这三个位置其中一个位置的钞票。

阿彭想要接住尽可能多的钞票（钞票面额相同），你能帮帮他吗？

Input
多组样例。每组样例输入一个 m (0 < m < 100000)，表示有 m 张钞票。

在接下来的 m 行中，每行有两个整数 a b (0 < b < 100000)，表示在第 b 秒的时候有一张钞票掉落在 a 点上。

注意，同一个点上同一秒可能掉落多张钞票。m = 0 时输入结束。

C++ 注意文件头不能使用 bits/stdc++.h，G++可以使用

java 类名 注意使用成 Main

Output
输出一个整数 x，表示阿彭 可能接住的最多的钞票数。

Sample Input
6
5 1
4 1
6 1
7 2
7 2
8 3
0
Sample Output

解题思路：因为一秒内只能够走一步，所以同一秒每个点只可能有三种状态，所以我们可以从最后一秒开始，递推求每个点在每个时刻可收获的最大钞票数，
递推公式 dp[i][j]=max(dp[i+1][j-1],max(dp[i+1][j],dp[i+1][j+1]));
**/

#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int max_n=1e5+10; 

int n,m;
int dp[max_n][12];

int main()
{
	while(cin>>n&&n) {
		memset(dp,0,sizeof dp);
		m=-1;
		for(int i=1;i<=n;i++){
			int a,b;
			cin>>a>>b;
			dp[b][a]++;
			m=max(m,b);
		}
		for(int i=m-1;i>=0;i--) {
			dp[i][0]+=max(dp[i+1][0],dp[i+1][1]);
			for(int j=1;j<=10;j++) {
				dp[i][j]+=max(dp[i+1][j],max(dp[i+1][j-1],dp[i+1][j+1]));
			}
		}
		cout<<dp[0][5]<<endl;
	}	
}
 
